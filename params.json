{"name":"Sabres","tagline":"Android ORM with Parse-like API","body":"**Sabres** is an Android ORM library that exposes a [Parse]-like API.\r\n\r\nLike [Parse] is has dual API: a callback based API and a [Bolts Tasks] based API.\r\n\r\nThe documentation covers only the callbacks API. But the Sample App covers both API's extensively.\r\n\r\n# Objects\r\n\r\n## The SabresObject\r\n\r\nStoring data in Sabres is built around the `SabresObject`. Each `SabresObject` contains key-value pairs of Sabres compatible data. This data is schemaless, which means that you don't need to specify ahead of time what keys exist on each `SabresObject`. You simply set whatever key-value pairs you want, and Sabres will store it.\r\n\r\nFor example, let's say you're building a movie database. A single `SabresObject` could contain:\r\n\r\n` Title: \"Fight Club\", Rating: 8.9, ViewCount: 6`\r\n\r\nKeys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays and objects. A Full list is supported types is found [here][www.fill_it_later.com].\r\n\r\n`SabresObject` is an abstract class and should be extended by custom classes.\r\n\r\n```java\r\npublic class Movie extends SabresObject {\r\n}\r\n```\r\n\r\n## Saving Objects\r\n\r\nLet's say you want to save the `Movie` described above to `Sabres`. The interface is similar to a `Map`, plus the `saveInBackground` method:\r\n\r\n```java\r\nMovie movie = new Movie();\r\nmovie.put(\"title\", \"Fight Club\");\r\nmovie.put(\"rating\", 8.9);\r\nmovie.put(\"viewCount\", 6);\r\nmovie.saveInBackground();\r\n```\r\n\r\nThere are a few fields you don't need to specify that are provided as a convenience. `objectId` is a unique identifier for each saved object. `createdAt` and `updatedAt` represent the time that each object was created and last modified in the database. Each of these fields is filled in by `Sabres`, so they don't exist on a `SabresObject` until a save operation has completed.\r\n\r\n## Retrieving Objects\r\n\r\nSaving data to `Sabres` is fun, but it's even more fun to get that data out again. If you have the objectId, you can retrieve the whole `SabresObject` using a `SabresQuery`:\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.getInBackground(3 /* this is the objectId */, new GetCallback<Movie>() {\r\n    @Override\r\n    public void done(Movie movie, SabresException e) {\r\n        if (e == null) {\r\n            // got movie.\r\n        } else {\r\n            // something went wrong.\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nTo get the values out of the `SabresObject`, there's a `getX` method for each data type:\r\n\r\n```java\r\nString title = movie.getString(\"title\");\r\nDouble rating = movie.getDouble(\"rating\");\r\nInteger viewCount= movie.getInt(\"viewCount\");\r\n```\r\n\r\nThe three special values have their own accessors:\r\n\r\n```java\r\nLong objectId = movie.getObjectId();\r\nDate updatedAt = movie.getUpdatedAt();\r\nDate createdAt = movie.getCreatedAt();\r\n```\r\n\r\nIf you need to refresh an object you already have with the latest data that is in `Sabres`, you can call the `fetchInBackground` method like so:\r\n\r\n```java\r\nmovie.fetchInBackground(new FetchCallback() {\r\n    @Override\r\n    public void done(SabresException e) {\r\n        if (e == null) {\r\n            // object fetched.\r\n        } else {\r\n            // something went wrong.\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nThe code in the `FetchCallback` will be run on the main thread.\r\n\r\n## Updating Objects\r\n\r\nUpdating an object is simple. Just set some new data on it and call one of the save methods. Assuming you have saved the object and have the objectId, you can retrieve the `SabresObject` using a `SabresQuery` and update its data:\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\n\r\n// Retrieve the object by id\r\nquery.getInBackground(3, new GetCallback<Movie>() {\r\n    public void done(Movie movie, SabresException e) {\r\n        if (e == null) {\r\n            movie.put(\"rating\", 9.1)\r\n            movie.put(\"viewCount\" , 7);\r\n            movie.saveInBackground();\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nSabres automatically figures out which data has changed so only \"dirty\" fields will be saved.\r\n\r\n## Counters\r\n\r\nThe above example contains a common use case. The \"viewCount\" field is a counter that we'll need to continually update with the number of times the movie was watched. Using the above method works but it's cumbersome and can lead to problems if you have multiple threads trying to update the same counter.\r\n\r\nTo help with storing counter-type data, Sabres provides methods that increment (or decrement) any number field. So, the same update can be rewritten as: \r\n\r\n```java\r\nmovie.increment(\"viewCount\");\r\nmovie.saveInBackground();\r\n```\r\n\r\nYou can also increment (or decrement) by any amount using `increment(key, amount)`.\r\n\r\n## Arrays\r\n\r\nTo help with storing array data, there are two operations that can be used to atomically change an array field:\r\n\r\n+ `add` and `addAll` append the given objects to the array. Only Unique object or values will be saved.\r\n\r\n+ `removeAll` removes all instances of the given objects from an array field.\r\n\r\nFor example, we can add items to the set-like \"actors\" field like so:\r\n\r\n```java\r\nmovie.addAll(\"actors\", Arrays.asList(\"Brad Pitt\", \"Edward Norton\"));\r\nmovie.saveInBackground();\r\n```\r\n\r\n## Deleting Objects\r\n\r\nTo delete an object from Sabres:\r\n\r\n```java\r\nmovie.deleteInBackground();\r\n```\r\n\r\nIf you want to run a callback when the delete is confirmed, you can provide a `DeleteCallback` to the `deleteInBackground` method. If you want to block the calling thread, you can use the `delete` method.\r\n\r\nYou can delete a single field from an object with the `remove` method:\r\n\r\n```java\r\n// After this, the rating field will be empty\r\nmovie.remove(\"rating\");\r\n\r\n// Saves the field deletion to Sabres\r\nmovie.saveInBackground();\r\n```\r\n\r\n## Relational Data\r\n\r\nObjects can have relationships with other objects. To model this behavior, any `SabresObject` can be used as a value in any other `SabresObject`.\r\n\r\nFor example, each `Movie` in a movie ratings app might correspond to one `Director`. To create a new `Movie` with a single `Director`, you could write:\r\n\r\n```java\r\n// Create the movie\r\nMovie movie = new Movie();\r\nmovie.put(\"title\", \"Fight Club\");\r\nmovie.put(\"rating\", 8.9);\r\n\r\n// Create the director\r\nDirector director = new Director();\r\ndirector.put(\"name\", \"David Fincher\");\r\n\r\n// Add a relation between the Movie and Director\r\nmovie.put(\"director\", director);\r\n\r\n// This will save both movie and director\r\nmovie.saveInBackground();\r\n```\r\n\r\nYou can also link objects using just their objectIds like so:\r\n\r\n```java\r\n// Add a relation between the Director with objectId \"5\" and the Movie\r\nmovie.put(\"director\", Director.createWithoutData(5));\r\n```\r\n\r\nBy default, when fetching an object, related SabresObjects are not fetched. These objects values cannot be retrieved until they have been fetched like so:\r\n\r\n```java\r\nfinal Director director = fetchedMovie.getSabresObject(\"director\");\r\ndirector.fetchIfNeededInBackground(new FetchCallback() {\r\n    public void done(SabresException e) {\r\n        if (e != null) {\r\n            String name = director.getString(\"name\");\r\n            // Do something with your new title variable\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n## Data Types\r\n\r\nSabresObjects can contain any of the following types:\r\n\r\n+ `String`\r\n\r\n+ `Number`\r\n\r\n+ `Boolean`\r\n\r\n+ `Date`\r\n\r\n+ object that extends `SabresObject`\r\n\r\n+ `List` of any of the above\r\n\r\n## Data Type Lock-in\r\n\r\nWhen a class is initially created, it doesn't have an inherent schema defined. This means that for the first object, it could have any types of fields you want.\r\n\r\nHowever, after a field has been set at least once, that field is locked into the particular type that was saved. For example, if a Movie object is saved with field title of type `String`, that field will be restricted to the `String` type only (`Sabres` will throw an error if you try to save anything else).\r\n\r\n## Subclasses\r\n\r\n### Subclassing `SabresObject`\r\n\r\nTo create a `SabresObject` subclass:\r\n\r\n1. Declare a subclass which extends `SabresObject`.\r\n\r\n2. Call SabresObject.registerSubclass(YourClass.class) in your Application `onCreate` before calling `Sabres.initialize()`. The following code successfully implements and registers the `Movie` subclass of `SabresObject`:\r\n\r\n```java\r\n// Movie.java\r\nimport com.sabres.SabresObject;\r\n\r\npublic class Movie extends SabresObject {\r\n}\r\n\r\n// MyApplication.java\r\nimport com.sabres.Sabres;\r\nimport android.app.Application;\r\n\r\npublic class MyApplication extends Application {\r\n    @Override\r\n    public void onCreate() {\r\n        super.onCreate();\r\n\r\n        SabresObject.registerSubclass(Movie.class);\r\n        Sabres.initialize(this);\r\n    }\r\n}\r\n```\r\n\r\n### Accessors, mutators, and methods\r\n\r\nAdding methods to your `SabresObject` subclass helps encapsulate logic about the class. You can keep all your logic about a subject in one place rather than using separate classes for business logic and storage/transmission logic.\r\n\r\nYou can add accessors and mutators for the fields of your `SabresObject` easily. Declare the getter and setter for the field as you normally would, but implement them in terms of `get()` and `put()`. The following example creates a title field in the `Movie` class:\r\n\r\n```java\r\n// Movie.java\r\npublic class Movie extends SabresObject {\r\n    public String getTitle() {\r\n        return getString(\"title\");\r\n    }\r\n\r\n    public void setTitle(String value) {\r\n        put(\"title\", value);\r\n    }\r\n}\r\n```\r\n\r\nYou can now access the title field using `movie.getTitle()` and assign to it using `movie.setTitle(\"Fight Club\")`. This allows your IDE to provide autocompletion as you develop your app and allows typos to be caught at compile-time.\r\n\r\nAccessors and mutators of various types can be easily defined in this manner using the various forms of `get()` such as `getInt()`, `getString()`, or `getList()`.\r\n\r\n### Initializing subclasses\r\n\r\nIf you define your own constructors to your subclass, you have to also define a no argument constructor that does not modify fields in the object. `Sabres` uses it to create strongly typed instances of your subclass.\r\n\r\n# Queries\r\n\r\n## Basic Queries\r\n\r\nIn many cases, `getInBackground` isn't powerful enough to specify which objects you want to retrieve. The `SabresQuery` offers different ways to retrieve a list of objects rather than just a single object.\r\n\r\nThe general pattern is to create a SabresQuery, put conditions on it, and then retrieve a List of matching SabresObjects using the `findInBackground` method with a `FindCallback`. For example, to retrieve movies with a particular directorName, use the `whereEqualTo` method to constrain the value for a key:\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.whereEqualTo(\"directorName\", \"Quentin Tarantino\");\r\nquery.findInBackground(new FindCallback<Movie>() {\r\n    public void done(List<Movie> movies, SabresException e) {\r\n        if (e == null) {\r\n            Log.d(\"movies\", \"Retrieved \" + movies.size() + \" movies\");\r\n        } else {\r\n            Log.d(\"movies\", \"Error: \" + e.getMessage());\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n`findInBackground` works similarly to `getInBackground` in that it assures the database operations are done on a background thread, and runs its callback in the main thread.\r\n\r\n## Query Constraints\r\n\r\nThere are several ways to put constraints on the objects found by a `SabresQuery`. You can filter out objects with a particular key-value pair with whereNotEqualTo:\r\n\r\n```java\r\nquery.whereNotEqualTo(\"directorName\", \"Guy Ritchie\");\r\n```\r\n\r\nYou can give multiple constraints, and objects will only be in the results if they match all of the constraints. In other words, it's like an AND of constraints.\r\n\r\n```java\r\nquery.whereNotEqualTo(\"directorName\", \"Guy Ritchie\");\r\nquery.whereGreaterThan(\"rating\", 8);\r\n```\r\n\r\nYou can limit the number of results with `setLimit`. By default, results are not limited.\r\n\r\n```java\r\nquery.setLimit(10); // limit to at most 10 results\r\n```\r\n\r\nIf you want exactly one result, a more convenient alternative may be to use `getFirst` or `getFirstBackground` instead of using find.\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.whereEqualTo(\"title\", \"Fight Club\");\r\nquery.getFirstInBackground(new GetCallback<Movie>() {\r\n    public void done(Movie movie, SabresException e) {\r\n        if (object == null) {\r\n            Log.d(\"movie\", \"The getFirst request failed.\");\r\n        } else {\r\n            Log.d(\"movie\", \"Retrieved the movie.\");\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nYou can skip the first results with `setSkip`. This can be useful for pagination:\r\n\r\n```java\r\nquery.setSkip(10); // skip the first 10 results\r\n```\r\n\r\nFor sortable types like numbers and strings, you can control the order in which results are returned:\r\n\r\n```java\r\n// Sorts the results in ascending order by the rating field.\r\nquery.addAscendingOrder(\"rating\");\r\n\r\n// Sorts the results in descending order by the title field if the previous sort keys are equal.\r\nquery.addDescendingOrder(\"title\");\r\n```\r\n\r\nFor sortable types, you can also use comparisons in queries:\r\n\r\n```java\r\n// Restricts to rating < 8\r\nquery.whereLessThan(\"rating\", 8);\r\n\r\n// Restricts to rating <= 8\r\nquery.whereLessThanOrEqualTo(\"rating\", 8);\r\n\r\n// Restricts to rating > 8\r\nquery.whereGreaterThan(\"rating\", 8);\r\n\r\n// Restricts to rating >= 8\r\nquery.whereGreaterThanOrEqualTo(\"rating\", 8);\r\n```\r\n\r\nIf you want to retrieve objects matching several different values, you can use `whereContainedIn`, providing a collection of acceptable values. This is often useful to replace multiple queries with a single query. For example, if you want to retrieve movies made by any director in a particular list:\r\n\r\n```java\r\nString[] names = {\"Guy Ritchie\", \"David Fincher\", \"Quentin Tarantino\"};\r\nquery.whereContainedIn(\"directorName\", Arrays.asList(names));\r\n```\r\n\r\nIf you want to retrieve objects that do not match any of several values you can use `whereNotContainedIn`, providing an array of acceptable values. For example, if you want to retrieve movies from directors besides those in a list:\r\n\r\n```java\r\nString[] names = {\"Guy Ritchie\", \"David Fincher\", \"Quentin Tarantino\"};\r\nquery.whereNotContainedIn(\"directorName\", Arrays.asList(names));\r\n```\r\n\r\nIf you want to retrieve objects that have a particular key set, you can use `whereExists`. Conversely, if you want to retrieve objects without a particular key set, you can use `whereDoesNotExist`.\r\n\r\n// Finds objects that have the rating set\r\nquery.whereExists(\"rating\");\r\n\r\n// Finds objects that don't have the rating set\r\nquery.whereDoesNotExist(\"rating\");\r\n\r\nYou can restrict the fields returned by calling `selectKeys` with a list of keys. To retrieve documents that contain only the `title` and `rating` fields (and also special built-in field  objectId):\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.selectKeys(Arrays.asList(\"title\", \"rating\"));\r\nList<Movie> results = query.find();\r\n```\r\n\r\n## Queries on Array Values\r\n\r\nIf a key contains an array value, you can search for objects where the key's array value contains a specific value by:\r\n\r\n```java\r\n// Find objects where the array in actors contains the string \"Brad Pitt\".\r\nquery.whereEqualTo(\"actors\", \"Brad Pitt\");\r\n```\r\n\r\nYou can also search for objects where the key's array value contains each of the values provided in a list:\r\n\r\n```java\r\n// Find objects where the array in actors contains all of the strings: \"Brad Pitt\", \"Edward Norton\" and \"Helena Bonham Carter\"\r\nArrayList<String> actors = new ArrayList<>();\r\nnumbers.add(\"Brad Pitt\");\r\nnumbers.add(\"Edward Norton\");\r\nnumbers.add(\"Helena Bonham Carter\");\r\nquery.whereContainsAll(\"actors\", actors);\r\n```\r\n\r\n## Queries on String Values\r\nUse whereStartsWith to restrict to string values that start with a particular string. Internally it uses the LIKE sqlite operator, this is indexed so it is efficient for large datasets:\r\n\r\n```java\r\n// Finds movies that start with \"Fight\".\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.whereStartsWith(\"title\", \"Fight\");\r\n```\r\n\r\n## Relational Queries\r\n\r\nIf you want to retrieve objects where a field matches a particular SabresObject, you can use whereEqualTo just like for other data types. For example, if each `Movie` has a `Director` object in its director field, you can fetch movies for a particular director:\r\n\r\n```java\r\n// Assume SabresObject director was previously created.\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.whereEqualTo(\"director\", director);\r\n\r\nquery.findInBackground(new FindCallback<Movie>() {\r\n    public void done(List<Movie> movies, SabresException e) {\r\n        if (e == null) {\r\n            // movies list contains all movies with the given director.\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nIn some situations, you want to return multiple types of related objects in one query. You can do this with the include method. For example, let's say you are retrieving the ten most rated movies, and you want to retrieve their directors at the same time:\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\n\r\n// Order by rating\r\nquery.orderByDescending(\"rating\");\r\n\r\n// Only retrieve the first ten\r\nquery.setLimit(10);\r\n\r\n// Include the director data with each movie\r\nquery.include(\"director\");\r\n\r\nquery.findInBackground(new FindCallback<Movie>() {\r\n    public void done(List<Movie> movies, SabresException e) {\r\n        if (e == null) {\r\n            // movies contain the 10 most highly rated films, and the \"director\" field is populated.\r\n            for (Movie movie : movies) {\r\n                Director director = movie.getSabresObject(\"director\");\r\n                Log.e(\"Best Director\", director.getString(\"name\"));\r\n            }\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n## Counting Objects\r\n\r\nIf you just need to count how many objects match a query, but you do not need to retrieve all the objects that match, you can use count instead of find. For example, to count how many movies a particular director directed:\r\n\r\n```java\r\nSabresQuery<Movie> query = SabresQuery.getQuery(Movie.class);\r\nquery.whereEqualTo(\"directorName\", \"Guy Ritchie\");\r\nquery.countInBackground(new CountCallback() {\r\n    public void done(Long count, SabresException e) {\r\n        if (e == null) {\r\n            // The count request succeeded. Log the count\r\n            Log.d(\"Director\", \"Guy Ritchie has directed \" + count + \" movies\");\r\n        } else {\r\n            // The request failed\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n## Compound Queries\r\n\r\nIf you want to find objects that match one of several queries, you can use `SabresQuery.or` method to construct a query that is an or of the queries passed in. For instance if you want to find movies who either have a high rating or a low rating, you can do:\r\n\r\n```java\r\nSabresQuery<Movie> highRating = SabresQuery.getQuery(Movie.class);\r\nhighRating.whereGreaterThan(\"rating\", 9);\r\n\r\nSabresQuery<Movie> lowRating = SabresQuery.getQuery(Movie.class);\r\nlowRating.whereLessThan(\"rating\", 5);\r\n\r\nList<SabresQuery<Movie>> queries = new ArrayList<>>();\r\nqueries.add(highRating);\r\nqueries.add(lowRating);\r\n\r\nSabresQuery<Movie> mainQuery = SabresQuery.or(queries);\r\nmainQuery.findInBackground(new FindCallback<Movie>() {\r\n    public void done(List<Movie> movies, SabresException e) {\r\n        if (e == null) {\r\n            // your results.\r\n        }\r\n    }\r\n});\r\n```\r\n\r\nNote that Sabres does not support non-filtering constraints (e.g. setLimit, skip, orderBy..., include) in the subqueries of the compound query.\r\n\r\n\r\n## License\r\n\r\n    Copyright 2015 Tamir Shomer\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n[Parse]: http://parse.com\r\n[Bolts Tasks]: https://github.com/BoltsFramework/Bolts-Android","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}